<table>
<tr>
  <th>S.NO.</th>
  <th>PRACTICAL</th>
</tr>

<tr>
  <td>1</td>
  <td><a href="P01.pl">Write a prolog to calculate the sum of two numbers.</a></td>
</tr>

<tr>
  <td>2</td>
  <td><a href="P02.pl">Write a Prolog to implement max(X, Y, M) so that M is the maximum of two numbers X and Y.</a></td>
</tr>

<tr>
  <td>3</td>
  <td><a href="P03.pl">Write a in PROLOG to implement factorial (N, F) where F represents the factorial of a number N.</a></td>
</tr>

<tr>
  <td>4</td>
  <td><a href="P04.pl">Write a in PROLOG to implement generate_fib(N,T) where T represents the Nth term of the fibonacci series.</a></td>
</tr>

<tr>
  <td>5</td>
  <td><a href="P05.pl">Write a Prolog to implement GCD of two numbers.</a></td>
</tr>

<tr>
  <td>6</td>
  <td><a href="P06.pl">Write a Prolog to implement power (Num,Pow, Ans) : where Num is raised to the power Pow to get Ans.</a></td>
</tr>

<tr>
  <td>7</td>
  <td><a href="P07.pl">Prolog to implement multi (N1, N2, R) : where N1 and N2 denotes the numbers to be multiplied and R represents the result.</a></td>
</tr>

<tr>
  <td>8</td>
  <td><a href="P08.pl">Write a in PROLOG to implement towerofhanoi (N) where N represents the number of discs.</a></td>
</tr>

<tr>
  <td>9</td>
  <td><a href="P09.pl">Consider a cyclic directed graph [edge (p, q), edge (q, r), edge (q, r), edge (q, s), edge (s,t)] where edge (A,B) is a predicate indicating directed edge in a graph from a node A to a node B. Write a to check whether there is a route from one node to another node.</a></td>
</tr>

<tr>
  <td>10</td>
  <td><a href="P10.pl">Write a Prolog to implement memb(X, L): to check whether X is a member of L or not.</a></td>
</tr>

<tr>
  <td>11</td>
  <td><a href="P11.pl">Write a Prolog to implement conc (L1, L2, L3) where L2 is the list to be appended with L1 to get the resulted list L3.</a></td>
</tr>

<tr>
  <td>12</td>
  <td><a href="P12.pl">Write a Prolog to implement reverse (L, R) where List L is original and List R is reversed list.</a></td>
</tr>

<tr>
  <td>13</td>
  <td><a href="P13.pl">Write a in PROLOG to implement palindrome (L) which checks whether a list L is a palindrome or not.</a></td>
</tr>

<tr>
  <td>14</td>
  <td><a href="P14.pl">Write a Prolog to implement sumlist(L, S) so that S is the sum of a given list L.</a></td>
</tr>

<tr>
  <td>15</td>
  <td><a href="P15.pl">Write a Prolog to implement two predicates evenlength(List) and oddlength(List) so that they are true if their argument is a list of even or odd length respectively.</a></td>
</tr>

<tr>
  <td>16</td>
  <td><a href="P16.pl">Write a Prolog to implement nth_element (N, L, X) where N is the desired position, L is a list and X represents the Nth element of L.</a></td>
</tr>

<tr>
  <td>17</td>
  <td><a href="P17.pl">Write a in PROLOG to implement remove_dup (L, R) where L denotes the list with some duplicates and the list R denotes the list with duplicates removed.</a></td>
</tr>

<tr>
  <td>18</td>
  <td><a href="P18.pl">Write a Prolog to implement maxlist(L, M) so that M is the maximum number in the list.</a></td>
</tr>

<tr>
  <td>19</td>
  <td><a href="P19.pl">Write a prolog to implement insert_nth(I, N, L, R) that inserts an item I into Nth position of list L to generate a list R.</a></td>
</tr>

<tr>
  <td>20</td>
  <td><a href="P20.pl">Write a in PROLOG to implement sublist(S, L) that checks whether the list S is the sublist of list L or not. (Check for sequence or the part in the same order).</a></td>
</tr>

<tr>
  <td>21</td>
  <td><a href="P21.pl">Write a Prolog to implement delete_nth (N, L, R) that removes the element on Nth position from a list L to generate a list R.</a></td>
</tr>

<tr>
  <td>22</td>
  <td><a href="P22.pl">Write a in PROLOG to implement delete_all (X, L, R) where X denotes the element whose all occurrences has to be deleted from list L to obtain list R.</a></td>
</tr>

<tr>
  <td>23</td>
  <td><a href="P23.pl">Write a in PROLOG to implement merge (L1, L2, L3) where L1 is first ordered list and L2 is second ordered list and L3 represents the merged list.</a></td>
</tr>

<tr>
  <td>24</td>
  <td><a href="P24.pl">Write a PROLOG that will take grammar rules in the following format:<br>
    &emsp;&emsp;&emsp;NT -> (NT | T)*<br>
    Where NT is any nonterminal, T is any terminal and Kleene star (*) signifies any number of repetitions, and generate the corresponding top-down parser, that is:<br>
    &emsp;&emsp;sentence -> noun-phrase, verb-phrase<br>
    &emsp;&emsp;determiner -> [the]<br>
    will generate the following:<br>
    &emsp;&emsp;sentence (I, O) :- noun-phrase(I,R), verb-phrase (R,O).<br>
    &emsp;&emsp;determiner ([the|X], X) :- !.</a>
  </td>
</tr>
</table>
